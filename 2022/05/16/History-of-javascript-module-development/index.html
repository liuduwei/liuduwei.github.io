<!DOCTYPE html><html class="appearance-dark" lang="en"><head><meta charset="UTF-8"><title>History of javascript module development</title><meta name="description" content="blog"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/ldw.jpg"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
Recently I came across an article call The Evolution of JavaScript Modularity from a github Repo, This article is so well-written, thus this is kind of a summary of that article.

The Name CollisionFrom the moment of its appearance JavaScript has used the global object window as a storage for all variables defined without the var keyword. In 1995-1999 it .."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">CcrazyCaiNiao's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">History of javascript module development</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Name-Collision"><span class="toc-text">The Name Collision</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Directly-Defined-Dependencies-1999"><span class="toc-text">Directly Defined Dependencies (1999)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Namespace-Pattern-2002"><span class="toc-text">The Namespace Pattern (2002)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Module-Pattern-2003"><span class="toc-text">The Module Pattern (2003)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Defined-Dependencies-2006"><span class="toc-text">Template Defined Dependencies (2006)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJs-Modules-2009"><span class="toc-text">CommonJs Modules (2009)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMD-2009"><span class="toc-text">AMD (2009)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UMD-2011"><span class="toc-text">UMD (2011)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES2015-Modules-2015"><span class="toc-text">ES2015 Modules (2015)</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Javascript"><i class="tag post-item-tag">Javascript</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">History of javascript module development</h1><time class="has-text-grey" datetime="2022-05-16T18:07:48.000Z">2022-05-16</time><article class="mt-2 post-content"><blockquote>
<p>Recently I came across an article call <a target="_blank" rel="noopener" href="https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity">The Evolution of JavaScript Modularity</a> from a github Repo, This article is so well-written, thus this is kind of a summary of that article.</p>
</blockquote>
<h3 id="The-Name-Collision"><a href="#The-Name-Collision" class="headerlink" title="The Name Collision"></a>The Name Collision</h3><p>From the moment of its appearance JavaScript has used the global object window as a storage for all variables defined without the <code>var</code> keyword. In 1995-1999 it was very convenient, because JavaScript code tended to solve small tasks that hadn’t required a lot of lines of code. But when the codebase of applications had became large this feature of the language began to lead to nasty errors because of the name collisions. Let’s look at this example:</p>
<pre><code>    // file greeting.js
    var helloInLang = &#123;
        en: &#39;Hello world!&#39;,
        es: &#39;¡Hola mundo!&#39;,
        ru: &#39;Привет мир!&#39;
    &#125;;

    function writeHello(lang) &#123;
        document.write(helloInLang[lang]);
    &#125;

    // file hello.js
    function writeHello() &#123;
        document.write(&#39;The script is broken&#39;);
    &#125;
</code></pre>
<p>When we place the script <code>greeting.js</code> on the page and after it <code>hello.js</code> there will be conflict, that is instead of the greeting we will get the message “The script is broken” in this particular case.</p>
<p>It is obvious that in the large projects this can cause a lot of headaches. Moreover you cannot be sure that the third-party scripts on the page won’t break anything in your app.</p>
<p>And there’s an another tedious moment that you need manual control of the <code>script</code> tag in the HTML.</p>
<h3 id="Directly-Defined-Dependencies-1999"><a href="#Directly-Defined-Dependencies-1999" class="headerlink" title="Directly Defined Dependencies (1999)"></a>Directly Defined Dependencies (1999)</h3><p>let’s look at the implementation of this pattern using Dojo Toolkit.</p>
<p>The gist of directly defined dependencies lied in the getting of the code of the modules (in terms of the Dojo - resources) via explicit invocation of the function dojo.require (which is also used to initialise the loaded module). That is in this approach the dependencies were defined directly in the code at those places, where they should to be used.</p>
<p>Let’s revise our example using Dojo 1.6:</p>
<pre><code class="javascript">// file greeting.js
dojo.provide(&quot;app.greeting&quot;);

app.greeting.helloInLang = &#123;
  en: &quot;Hello world!&quot;,
  es: &quot;¡Hola mundo!&quot;,
  ru: &quot;Привет мир!&quot;,
&#125;;

app.greeting.sayHello = function (lang) &#123;
  return app.greeting.helloInLang[lang];
&#125;;

// file hello.js
dojo.provide(&quot;app.hello&quot;);

dojo.require(&quot;app.greeting&quot;);

app.hello = function (x) &#123;
  document.write(app.greeting.sayHello(&quot;es&quot;));
&#125;;
</code></pre>
<p>Here we see that modules are defined using the function dojo.provide, and the process of getting of the code of the module starts when you use dojo.require. It is a fairly simple approach that was used in the Dojo up to version 1.7; Google Closure Library uses it to this day.</p>
<h3 id="The-Namespace-Pattern-2002"><a href="#The-Namespace-Pattern-2002" class="headerlink" title="The Namespace Pattern (2002)"></a>The Namespace Pattern (2002)</h3><blockquote>
<p>For sloving the issue with name collisions, the namespace pattern was introduced. usually, It is a way to create an Object mounted in Window all method and properties we need reside in it.</p>
</blockquote>
<p>Actually Dojo mentioned before in the previous chapter which already use this Parttern.</p>
<p>If we apply this idea to our example we get something like this:</p>
<pre><code class="javascript">// file app.js
var app = &#123;&#125;;

// file greeting.js
app.helloInLang = &#123;
  en: &quot;Hello world!&quot;,
  es: &quot;¡Hola mundo!&quot;,
  ru: &quot;Привет мир!&quot;,
&#125;;

// file hello.js
app.writeHello = function (lang) &#123;
  document.write(app.helloInLang[lang]);
&#125;;
</code></pre>
<p>As we can see the logic and the data resides now in the properties of the object app. Thus we don’t pollute the global scope but continue to have access to the various parts of the application from different files.</p>
<p>But there is a significant flaw that we can modify all the properties of the app object from the global scope.</p>
<h3 id="The-Module-Pattern-2003"><a href="#The-Module-Pattern-2003" class="headerlink" title="The Module Pattern (2003)"></a>The Module Pattern (2003)</h3><blockquote>
<p>It’s main idea is encapsulating data and code with a closure and providing access to them through methods accessible from the outside.</p>
</blockquote>
<p>Here is a basic example of this type of pattern:</p>
<pre><code class="javascript">var greeting = (function () &#123;
  var module = &#123;&#125;;

  var helloInLang = &#123;
    en: &quot;Hello world!&quot;,
    es: &quot;¡Hola mundo!&quot;,
    ru: &quot;Привет мир!&quot;,
  &#125;;

  module.getHello = function (lang) &#123;
    return helloInLang[lang];
  &#125;;

  module.writeHello = function (lang) &#123;
    document.write(module.getHello(lang));
  &#125;;

  return module;
&#125;)();
</code></pre>
<p>Here we see the immediately invoked function express, and We can see that the module pattern is very similar to the previous one, but now the data and the methods are encapsulated in a closure.<br>Dive in deep see article <a target="_blank" rel="noopener" href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">JavaScript Module Pattern: In-Depth</a></p>
<h3 id="Template-Defined-Dependencies-2006"><a href="#Template-Defined-Dependencies-2006" class="headerlink" title="Template Defined Dependencies (2006)"></a>Template Defined Dependencies (2006)</h3><blockquote>
<p>This pattern defines dependencies via inclusion into the target file the special labels.<br>The similars:<br>Comment Defined Dependencies (2006)<br>Externally Defined Dependencies (2007)</p>
</blockquote>
<p>The resolving this labels into actual code can be performed via templating, and special build tools, for example, borshik. In contrast to the previous discussed detached dependency definitions patterns, this pattern only works with pre-build step.</p>
<p>For example:</p>
<pre><code class="javascript">// file app.tmp.js

/*borschik:include:../lib/main.js*/

/*borschik:include:../lib/helloInLang.js*/

/*borschik:include:../lib/writeHello.js*/

// file main.js
var app = &#123;&#125;;

// file helloInLang.js
app.helloInLang = &#123;
  en: &quot;Hello world!&quot;,
  es: &quot;¡Hola mundo!&quot;,
  ru: &quot;Привет мир!&quot;,
&#125;;

// file writeHello.js
app.writeHello = function (lang) &#123;
  document.write(app.helloInLang[lang]);
&#125;;
</code></pre>
<h3 id="CommonJs-Modules-2009"><a href="#CommonJs-Modules-2009" class="headerlink" title="CommonJs Modules (2009)"></a>CommonJs Modules (2009)</h3><blockquote>
<p>CommonJS is the most common module format at the present moment. You can use it not only on the server-side in Node.JS but also on the client-side using Browserfiy or Webpack, which can transform set of CommonJS modules into one bundle.</p>
</blockquote>
<p>As an example of the CommonJS module let’s adapt our module by this way:</p>
<pre><code class="javascript">// file greeting.js
var helloInLang = &#123;
  en: &quot;Hello world!&quot;,
  es: &quot;¡Hola mundo!&quot;,
  ru: &quot;Привет мир!&quot;,
&#125;;

var sayHello = function (lang) &#123;
  return helloInLang[lang];
&#125;;

module.exports.sayHello = sayHello;

// file hello.js
var sayHello = require(&quot;./lib/greeting&quot;).sayHello;
var phrase = sayHello(&quot;en&quot;);
console.log(phrase);
</code></pre>
<h3 id="AMD-2009"><a href="#AMD-2009" class="headerlink" title="AMD (2009)"></a>AMD (2009)</h3><blockquote>
<p>Base the CommonJs, But loading of the modules should not synchronous, use the browser functionality for the parallel loading of the scripts</p>
</blockquote>
<p>If we will rewrite our example using AMD format we will get something like this:</p>
<pre><code class="javascript">// file lib/greeting.js
define(function () &#123;
  var helloInLang = &#123;
    en: &quot;Hello world!&quot;,
    es: &quot;¡Hola mundo!&quot;,
    ru: &quot;Привет мир!&quot;,
  &#125;;

  return &#123;
    sayHello: function (lang) &#123;
      return helloInLang[lang];
    &#125;,
  &#125;;
&#125;);

// file hello.js
define([&quot;./lib/greeting&quot;], function (greeting) &#123;
  var phrase = greeting.sayHello(&quot;en&quot;);
  document.write(phrase);
&#125;);
</code></pre>
<p>The file hello.js is the entry point of the program. In this file there is a function define that declares a module. The first argument of the function is an array of dependencies. The execution of the code of the module, which is defined as a function in the second argument of define, will be launched only after that fact when all dependencies of this module will be loaded. This deferred code execution of the module makes a possibility for the parallel loading of its dependencies.</p>
<h3 id="UMD-2011"><a href="#UMD-2011" class="headerlink" title="UMD (2011)"></a>UMD (2011)</h3><blockquote>
<p>There were two formats, CommonJs and AMD, could not get along with each other, so UMD format has been developed for solution of this problem.</p>
</blockquote>
<p>As an example let’s refactor our module greeting.js for the simultaneous support of different environments CommonJS and AMD:</p>
<pre><code class="javascript">(function (define) &#123;
  define(function () &#123;
    var helloInLang = &#123;
      en: &quot;Hello world!&quot;,
      es: &quot;¡Hola mundo!&quot;,
      ru: &quot;Привет мир!&quot;,
    &#125;;

    return &#123;
      sayHello: function (lang) &#123;
        return helloInLang[lang];
      &#125;,
    &#125;;
  &#125;);
&#125;)(
  typeof module === &quot;object&quot; &amp;&amp; module.exports &amp;&amp; typeof define !== &quot;function&quot;
    ? function (factory) &#123;
        module.exports = factory();
      &#125;
    : define
);
</code></pre>
<p>In the heart of this implementation pattern lies the immediately invoked function expression. That function takes different arguments depending on the environment. The passed argument is the following function if the code is used as a CommonJS module:</p>
<pre><code class="Javascript">function (factory) &#123;
    module.exports = factory();
&#125;
</code></pre>
<p>If the code is used as an AMD module, the argument of function is define. Due this substitution the code can be used in different environments.</p>
<h3 id="ES2015-Modules-2015"><a href="#ES2015-Modules-2015" class="headerlink" title="ES2015 Modules (2015)"></a>ES2015 Modules (2015)</h3><p>By tradition, let’s adapt our example to show the specification in action:</p>
<pre><code class="javascript">// file lib/greeting.js
const helloInLang = &#123;
  en: &quot;Hello world!&quot;,
  es: &quot;¡Hola mundo!&quot;,
  ru: &quot;Привет мир!&quot;,
&#125;;

export const greeting = &#123;
  sayHello: function (lang) &#123;
    return helloInLang[lang];
  &#125;,
&#125;;

// file hello.js
import &#123; greeting &#125; from &quot;./lib/greeting&quot;;
const phrase = greeting.sayHello(&quot;en&quot;);
document.write(phrase);
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/06/17/var-let-what-s-difference-in-the-for-loop/" title="var, let - what's difference in the for loop"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: var, let - what's difference in the for loop</span></a><a class="button is-default" href="/2022/04/16/Var-let-const/" title="The Var, let, Const - What's the Difference?"><span class="has-text-weight-semibold">Next: The Var, let, Const - What's the Difference?</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="https://github.com/liuduwei/liuduwei.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/liuduwei"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> CcrazyCaiNiao 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>